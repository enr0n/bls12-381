/**
 * Operations and utilities for working with elements in BLS12-381's G_1 group.
 * G_1 is the r-torsion of the curve E: y^2 = x^3 + 4 defined over the field F_p.
 *
 * Generally, each type and function will have an _affine and _proj variant, with
 * the exception of the group operations themselves which are implemented with
 * algorithms using projective coordinates.
 */
#ifndef _G1_H_
#define _G1_H_

#include <stdbool.h>
#include <gmp.h>

/* A group element represented in affine coordinates. */
typedef struct {
    mpz_t x;
    mpz_t y;

    /* Indicate this is a point at infinity. */
    bool infinity;
} G1_elem_affine;

/* A group element represented in projective coordinates. */
typedef struct {
    mpz_t x;
    mpz_t y;
    mpz_t z;
} G1_elem_proj;

/* Covert affine to projective, and vice versa. */
void G1_affine2proj(G1_elem_proj *proj, const G1_elem_affine *affn);
void G1_proj2affine(G1_elem_affine *affn, const G1_elem_proj *proj);

/**
 * Initialize a group element from the provided strings. Using these
 * functions does not guarantee that the resulting point will lie on
 * the curve E. These should only be used when the input is known to
 * produce a group element, such as initializing generators from well
 * known parameters.
 */
void G1_elem_affine_from_str(G1_elem_affine *P, const char *x, const char *y);
void G1_elem_proj_from_str(G1_elem_proj *P, const char *x, const char *y, const char *z);

/**
 * Initialize a group element as the identity, i.e. the point at infinity.
 */
void G1_identity_init_affine(G1_elem_affine *e);
void G1_identity_init_proj(G1_elem_proj *e);

/**
 * Initialize a group element as a particular generator, namely the base point
 * defined here:
 *
 * https://tools.ietf.org/id/draft-irtf-cfrg-pairing-friendly-curves-08.html#section-4.2.1-10.1.1
 *
 * Note that because G_1 is prime order, all points are generators.
 */
void G1_generator_init_affine(G1_elem_affine *g);
void G1_generator_init_proj(G1_elem_proj *g);

/**
 * Free the memory held by the group element data structure.
 */
void G1_elem_free_affine(G1_elem_affine *P);
void G1_elem_free_proj(G1_elem_proj *P);

/**
 * Make sure the point lies on the curve E. This should always be true
 * when using points generated by this API. This may NOT be true for
 * points initialized by G1_elem_affine_from_str or G1_elem_proj_from_str.
 */
bool G1_is_on_curve_affine(const G1_elem_affine *P);
bool G1_is_on_curve_proj(const G1_elem_proj *P);

/**
 * Check if the element P is the identity element.
 */
bool G1_is_identity_affine(const G1_elem_affine *P);
bool G1_is_identity_proj(const G1_elem_proj *P);

/**
 * Check if the elements P and Q are in the same equivalency class.
 */
bool G1_equiv_affine(const G1_elem_affine *P, const G1_elem_affine *Q);
bool G1_equiv_proj(const G1_elem_proj *P, const G1_elem_proj *Q);

/**
 * Negate an element in G_1.
 */
void G1_negate_affine(G1_elem_affine *r, const G1_elem_affine *P);
void G1_negate_proj(G1_elem_proj *r, const G1_elem_proj *P);

/**
 * Group operations.
 *
 * Each of these returns the result in projective coordinates.
 */
void G1_double_proj(G1_elem_proj *r, const G1_elem_proj *P);
void G1_add_proj(G1_elem_proj *r, const G1_elem_proj *P, const G1_elem_proj *Q);
void G1_add_mixed(G1_elem_proj *r, const G1_elem_proj *P, const G1_elem_affine *Q);

#endif /* _G1_H_ */
